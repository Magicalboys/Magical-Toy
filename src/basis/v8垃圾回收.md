## 垃圾回收

所有的对象类型的数据在JS中都是通过堆进行空间分配的。当我们构造一个对象进行赋值操作的时候，其实相应的内存 已经分配到了堆上。
你可以不断的这样创建对象，让 V8 为它分配空间，直到堆的大小达到上限。
那为什么要给 V8 设置内存上限呢？
究其根本，是由两个因素所共同决定的，一个是JS单线程的执行机制，另一个是JS垃圾回收机制的限制。

首先JS是单线程运行的，这意味着一旦进入到垃圾回收，那么其它的各种运行逻辑都要暂停; 另一方面垃圾回收其实是非常耗时间的操作。
而且在这么长的时间内，我们的JS代码执行会一直没有响应，造成应用卡顿，导致应用性能和响应能力直线下降。
因此，V8 做了一个简单粗暴的 选择，那就是限制堆内存，也算是一种权衡的手段，因为大部分情况是不会遇到操作几个G内存这样的场景的。

V8 把堆内存分成了两部分进行处理——新生代内存和老生代内存。
顾名思义，新生代就是临时分配的内存，存活时间短， 老生代是常驻内存，存活的时间长。V8 的堆内存，也就是两个内存 之和。

![alt text](image.png)

根据这两种不同种类的堆内存，V8 采用了不同的回收策略，来根据不同的场景做针对性的优化。

## 新生代
首先是新生代的内存，因为新生代中的变量存活时间短，来了马上就走，不容易产生太大的内存负担。
所以 在 新生代的内存 64 位和 32 位系统下分别为 32MB 和 16MB，非常小。

新生代的垃圾回收具体 流程：

首先将新生代内存空间一分为二:

当新生代中对象生命周期短暂。垃圾回收比较繁琐，使用了基于Scavenge算法的垃圾回收策略，

在新生代当中，V8将内存分为两个相等的空间，分别为From空间和To空间。其中 From 部分表示正在使用的内存，To 是目前闲置的内存。
当 From 空间被占满的时候，V8会将 Form 空间中存活对象 按照顺序从头复制到 To 空间，并且将 Form 空间 非存活对象 进行清空，
然后将From空间和To空间交换，这样就完成了一次垃圾回收，然后不断循环。

### 为什么不能直接将非存活对象回收？

其实是为来解决 内存碎片 问题的，所谓内存碎片是指在内存分配和释放过程中产生的一种现象，即内存被分成多个小块，而这些小块之间存在未被使用的空间，无法被有效利用。

## 老生代

老生代中对象生命周期较长，垃圾回收比较复杂，使用了基于标记清除，标记整理，增量标记等算法的垃圾回收策略。

在老生代中，V8会通过标记-清楚算法和标记-整理算法进行垃圾回收。

标记-清除算法首先会遍历整个对象图，并且将所有的对象活动标记出来，然后清除未标记的对象。

标记-整理算法则会将所有活动对象移动到内存的一端，然后将另一端的空间全部清空，这样就可以获得一块连续的内存空间。

为了避免垃圾回收时间过长导致的阻塞，V8还采用了增量标记算法，将垃圾回收的过程拆分成多个阶段，每个阶段完成后都会让JavaScript程序执行一段时间。
